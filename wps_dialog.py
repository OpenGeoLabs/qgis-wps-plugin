# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeoDataDialog
                                 A QGIS plugin
 This plugin gathers cz/sk data sources.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-08-04
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Test
        email                : test
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import webbrowser

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt import QtGui
from qgis.utils import iface
from qgis.core import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtWidgets import *
from qgis.gui import *

from .connect import *

owslib_exists = True
try:
    from owslib.wps import WebProcessingService
    from owslib.wps import ComplexDataInput
    from owslib.util import getTypedValue
except:
    owslib_exists = False

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'wps_dialog_base.ui'))


class WpsDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(WpsDialog, self).__init__(parent)
        self.iface = iface
        self.setupUi(self)
        self.pushButtonAbout.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "icons/cropped-opengeolabs-logo-small.png")))
        self.pushButtonAbout.clicked.connect(self.showAbout)
        if owslib_exists and self.check_owslib_fix():
            self.pushButtonLoadProcesses.clicked.connect(self.load_processes)
            self.pushButtonLoadProcess.clicked.connect(self.load_process)
            self.verticalLayoutInputs = QVBoxLayout(self.tabInputs)
            self.pushButtonExecute.clicked.connect(self.execute_process)
            self.comboBoxProcesses.currentIndexChanged.connect(self.process_selected)
            self.input_items = {}
            self.input_items_all = []
            self.processes = []
        else:
            QMessageBox.information(None, self.tr("ERROR:"), self.tr("You have to install OWSlib with fix."))

    def check_owslib_fix(self):
        try:
            val = getTypedValue('integer', None)
            return True
        except:
            return False

    def load_processes(self):
        self.textEditLog.append(self.tr("Loading processes ..."))
        self.loadProcesses = GetProcesses()
        self.loadProcesses.setUrl(self.lineEditWpsUrl.text())
        self.loadProcesses.statusChanged.connect(self.on_load_processes_response)
        self.loadProcesses.start()

    def on_load_processes_response(self, response):
        if response.status == 200:
            self.comboBoxProcesses.clear()
            self.processes = response.data
            for proc in self.processes:
                self.comboBoxProcesses.addItem(proc.title)
            self.show_process_description(0)
            self.pushButtonLoadProcess.setEnabled(True)
            self.textEditLog.append(self.tr("Processes loaded"))
        else:
            QMessageBox.information(None, self.tr("ERROR:"), self.tr("Error loading processes"))
            self.textEditLog.append(self.tr("Error loading processes"))

    def show_process_description(self, index):
        self.textEditProcessDescription.setText("[" + self.processes[index].identifier + "]: " + self.processes[index].abstract)

    def process_selected(self):
        current_index = self.comboBoxProcesses.currentIndex()
        self.show_process_description(current_index)

    def get_all_layers_input(self):
        return QgsMapLayerComboBox(self.tabInputs)

    def get_input(self, identifier, title, data_type, default_value, min_occurs):
        # TODO check types
        input_item = None
        if data_type == 'ComplexData':
            input_item = self.get_all_layers_input()
        else:
            input_item = QLineEdit(self.tabInputs)
            input_item.setText(str(default_value))
        hbox_layout = QHBoxLayout(self.tabInputs)
        vbox_layout = QVBoxLayout(self.tabInputs)
        label = QLabel(self.tabInputs)
        label.setFixedWidth(200)
        label.setText(str(title))
        label.setWordWrap(True)
        vbox_layout.addWidget(label)
        label_id = QLabel(self.tabInputs)
        label_id.setFixedWidth(200)
        label_id.setWordWrap(True)
        label_id.setText("[" + str(identifier) + "]")
        if min_occurs > 0:
            label_id.setStyleSheet("QLabel { color : red; }");
        vbox_layout.addWidget(label_id)
        hbox_layout.addLayout(vbox_layout)
        hbox_layout.addWidget(input_item)
        # TODO check if there is not a better way
        self.input_items[str(identifier)] = input_item
        self.input_items_all.append(input_item)
        self.input_items_all.append(label)
        self.input_items_all.append(label_id)
        return hbox_layout

    def get_process_identifier(self):
        return self.processes[self.comboBoxProcesses.currentIndex()].identifier

    def load_process(self):
        process_identifier = self.get_process_identifier()
        self.textEditLog.append(self.tr("Loading process {}...".format(process_identifier)))
        self.loadProcess = GetProcess()
        self.loadProcess.setUrl(self.lineEditWpsUrl.text())
        self.loadProcess.setIdentifier(process_identifier)
        self.loadProcess.statusChanged.connect(self.on_load_process_response)
        self.loadProcess.start()

    def item_remove(self):
        for item_to_remove in self.input_items_all:
            item_to_remove.setParent(None)

    def on_load_process_response(self, response):
        process_identifier = self.get_process_identifier()
        if response.status == 200:
            if response.data.abstract is not None:
                self.item_remove()
                self.textEditProcessDescription.setText(response.data.abstract)
                self.input_items = {}
                self.pushButtonExecute.setEnabled(True)
                for x in response.data.dataInputs:
                    # print(dir(x))
                    input_item = self.get_input(x.identifier, x.title, x.dataType, x.defaultValue, x.minOccurs)
                    self.verticalLayoutInputs.addLayout(input_item)
                self.tabInputs.setLayout(self.verticalLayoutInputs)
            self.textEditLog.append(self.tr("Process {} loaded".format(process_identifier)))
        else:
            QMessageBox.information(None, self.tr("ERROR:"),
                                    self.tr("Error loading process {}".format(process_identifier)))
            self.textEditLog.append(self.tr("Error loading process {}".format(process_identifier)))

    def execute_process(self):
        # Async call: https://ouranosinc.github.io/pavics-sdi/tutorials/wps_with_python.html
        process_identifier = self.get_process_identifier()
        myinputs = []
        for param, widget in self.input_items.items():
            if isinstance(widget, QgsMapLayerComboBox):
                # TODO check input type and export into it (GML, GeoPackage, etc.)
                layer = widget.currentLayer()
                if layer is None:
                    iface.messageBar().pushMessage(self.tr("Error"), self.tr("There is not any layer"), level=Qgis.Critical)
                    return
                if layer.type() == QgsMapLayer.VectorLayer:
                    tmp_ext = '.gml'
                    tmp_frmt = 'GML'
                else:
                    iface.messageBar().pushMessage("Error", "Unsupported map layer type", level=Qgis.Critical)
                    return

                tmp_file = QgsProcessingUtils.generateTempFilename(
                    process_identifier + '_' + param) + tmp_ext
                QgsVectorFileWriter.writeAsVectorFormat(
                    layer,
                    tmp_file,
                    fileEncoding="UTF-8",
                    driverName=tmp_frmt
                )
                with open(tmp_file) as fd:
                    cdi = ComplexDataInput(fd.read())
                myinputs.append((param, cdi))
            else:
                # TODO check also other types than just QLineEdit
                if widget.text() != 'None':
                    myinputs.append((param, widget.text()))
        self.textEditLog.append(self.tr("Executing {} process ...".format(process_identifier)))
        self.executeProcess = ExecuteProcess()
        self.executeProcess.setUrl(self.lineEditWpsUrl.text())
        self.executeProcess.setIdentifier(process_identifier)
        self.executeProcess.setInputs(myinputs)
        self.executeProcess.statusChanged.connect(self.on_execute_process_response)
        self.executeProcess.start()

    def on_execute_process_response(self, response):
        process_identifier = self.get_process_identifier()
        if response.status == 200:
            self.textEditLog.append(self.tr("Process {} executed".format(process_identifier)))
            # TODO check output type
            vector = QgsVectorLayer('/vsizip/' + response.filepath, "process {} output".format(process_identifier), "ogr")
            if vector.isValid():
                QgsProject.instance().addMapLayer(vector)
                self.textEditLog.append(self.tr("Output data loaded into the map"))
            else:
                QMessageBox.information(None, self.tr("ERROR:"), self.tr("Can not load output data into map"))
                self.textEditLog.append(self.tr("Can not load output data into map"))
                self.textEditLog.append(self.tr("Showing content of the file"))
                self.appendFileContentIntoLog(response.filepath)
        else:
            QMessageBox.information(None, self.tr("ERROR:"),
                                    self.tr("Error executing process {}".format(process_identifier)))
            self.textEditLog.append(self.tr("Error executing process {}".format(process_identifier)))
            self.textEditLog.append(response.data)

    def appendFileContentIntoLog(self, file):
        with (open(file, "r")) as f:
            self.textEditLog.append(str(f.read()))

    def showAbout(self):
        try:
            webbrowser.get().open("http://opengeolabs.cz")
        except (webbrowser.Error):
            self.iface.messageBar().pushMessage(self.tr("GeoData", "Error"), self.tr("GeoData", "Can not find web browser to open page about"), level=Qgis.Critical)
